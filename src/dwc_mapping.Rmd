---
title: "Darwin Core mapping"
subtitle: "For: Manual of the Alien Plants of Belgium"
author:
- Lien Reyserhove
- Peter Desmet
- Quentin Groom
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/alien-plants-belgium/blob/master/src/dwc_mapping.Rmd).

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(readxl)         # To read Excel files
library(digest)         # To generate hashes
```


# Read source data

Create a data frame `input_data` from the source data:
 
```{r}
input_data <- read_excel(path = here("data", "raw", "checklist.xlsx")) 
```

# Preprocessing: tidy data and add taxon ID's

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. We have created one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name and kingdom. Once this is created, it is added to the source data. 

```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

input_data <-
  input_data %>%
  remove_empty("rows") %>%
  clean_names() %>%
  mutate(
    taxon_id = paste(
      "alien-plants-belgium",
      "taxon",
      vdigest (taxon, algo="md5"),
      sep = ":"
    )
  )
```


# Darwin Core mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml):

## Taxon core

```{r}
taxon <- input_data %>% 
  distinct(taxon_id, .keep_all = TRUE) %>%  # Create a dataframe with unique taxa only (ignoring multiple distribution rows)
  mutate(
    language = "en",
    license = "http://creativecommons.org/publicdomain/zero/1.0/",
    rightsHolder = "Botanic Garden Meise",
    datasetID = "https://doi.org/10.15468/wtda1m",
    datasetName = "Manual of the Alien Plants of Belgium",
    taxonID = taxon_id,
    scientificNameID = scientific_name_id,
    scientificName = taxon,
    kingdom = "Plantae",
    family = family,
    taxonRank = taxon_rank,
    nomenclaturalCode = "ICN"
  ) %>% 
    arrange(taxonID) %>% 
    select("language", "license", "rightsHolder", "datasetID", "datasetName", "taxonID", "scientificNameID","scientificName","kingdom", "family", "taxonRank", "nomenclaturalCode")
```

## Distribution extension

```{r start_distribution}
distribution <- input_data
```

### Clean date information

Create `start_year` from `fr`: 

```{r}
distribution <- 
  distribution %>% 
    mutate(start_year = str_replace_all(fr, "(\\?|ca. |<|>)", "")) %>%  # Strip ?, ca., < and >)
    mutate(end_year = str_replace_all(mrr, "(\\?|ca. |<|>)", "")) %>% # Strip ?, ca., < and >
    mutate(end_year = recode(end_year, 
                             "Ann." = format(Sys.Date(), "%Y"),
                             "N" = format(Sys.Date(), "%Y"))) %>%  # If `end_year` is `Ann.` or `N` use current year:
    mutate(date = case_when(
      start_year == "" & end_year == "" ~ "",
      start_year == ""                  ~ end_year,
      end_year == ""                    ~ start_year,
      start_year == end_year            ~ start_year,
      TRUE                              ~ paste(start_year, end_year, sep = "/")))

```

### Generate new dataframe for extinct species

UPDATE: this part should be reviewed for the next update!

Some species have two values for `occurrenceStatus` and `eventDate`, i.e. species with the degree of naturalisation (`d_n`) of extinct (`Ext.`) or extinct/casual (`Ext./Cas.`).

 > Extinct: introduced taxa that once were naturalized (usually rather locally) but that have not been confirmed in recent times in their known localities. Only taxa that are certainly extinct are indicated as such.   
 > Extinct/casual: Some of these extinct taxa are no longer considered as naturalized but still occur as casuals; such taxa are indicated as “Ext./Cas.” (for instance _Tragopogon porrifolius_).
 
For these species, we include the occurrenceStatus **within** the specified time frame (`eventDate` = first - most recent observation) and **after** the last observation (`eventDate` = most recent observation - current date).

```{r}
# distribution_extinct <- distribution %>% filter(d_n == "Ext." | d_n == "Ext./Cas.")
```

Map `occurrenceStatus` and `eventDate` for `occurrenceStatus_ALO`:

```{r}
# occurrenceStatus_ALO %<>% mutate(occurrenceStatus = case_when(
#  d_n == "Ext." ~ "absent",
#  d_n == "Ext./Cas." ~ "present"
# ))

# occurrenceStatus_ALO %<>% mutate(eventDate = case_when(
#  presence == "S" ~ paste(end_year, current_year, sep = "/")
# ))
```

Bind `occurrenceStatus_ALO` and `distribution` by rows:

```{r}
# distribution %<>% bind_rows(occurrenceStatus_ALO)
```


### Generate distribution for Flanders, Brussels and Wallonia

Before we start mapping the distribution extensions, we focus on two terms: `occurrenceStatus` and  `eventDate`:

This is because information on the occurrences is given for the **regions**, while date information is given for **Belgium** as a whole. Some transformations and clarifications are needed.

The easiest way to do use a stepwize approach:
1. Clean presence information and date information in `distribution`
2. Create a separate dataframe `occurrenceStatus_ALO` (ALO = after last observation) for extinct and extinct/casual species
3. Map `occurrenceStatus` and `eventDate` from cleaned presence and date information in `distribution` (for `eventDate` = first - most recent observation)
4. Map `occurrenceStatus` and `eventDate` from cleaned presence and date information in `occurrenceStatus_ALO` (for `eventDate` = most recent observation - current date)
5. Bind both dataframes by row.
6. Map the other Darwin Core terms in the distribution extension

The checklist contains minimal presence information (`X`,`?` or `NA`) for the three regions in Belgium: Flanders, Wallonia and the Brussels-Capital Region, contained in `presence_fl`, `presence_wa` and `presence_br` respectively. Information regarding the first/last recorded observation applies to the distribution in Belgium as a whole. Both national and regional information is required in the checklist. In the `distribution.csv`, we will first provide `occurrenceStatus` and `eventDate`` on a **national level**, followed by specific information for the **regions**. 

For this, we use the following principles:

1. When a species is present in _only one region_, we can assume `eventDate` relates to that specific region. In this case, we can keep lines for Belgium and for the specific region populated with these variables (see #45).

2. When a species is present in _more than one_ region, it is impossible to extrapolate the date information for the regions. In this case, we decided to provide `occurrenceStatus` for the regional information, and specify dates only for Belgium.  

Thus, we need to specify when a species is present in only one of the regions.

We generate 4 new columns: `Flanders`, `Brussels`,`Wallonia` and `Belgium`. 
The content of these columns refers to the specific presence status of a species on a regional or national level.
`S` if present in a single region or in Belgium, `?` if presence uncertain, `NA` if absent and `M` if present in multiple regions.

This should look like this:

```{r echo=FALSE}
as.data.frame(matrix(
  c(
    "X", NA, NA, "S", NA, NA, "S",
    NA, "X", NA, NA, "S", NA, "S", 
    NA, NA, "x", NA, NA, "S", "S",
    "X", "X", NA, "M", "M", NA, "S",
    "X", NA, "X", "M", NA, "M", "S",
    NA, "X", "X", NA, "M", "M", "S",
    NA, NA, NA, NA, NA, NA, NA,
    "X", "?", NA, "S", "?", NA, "S",
    "X", NA, "?", "S", NA, "?", "S",
    "X", "X", "?", "M", "M", "?", "S"
  ),
  ncol = 7,
  byrow = TRUE,
  dimnames = list(c(1:10), c(
    "presence_fl",
    "presence_br", 
    "presence_wa", 
    "Flanders", 
    "Brussels", 
    "Wallonia",
    "Belgium"
  ))
))
```

We translate this to the distribution extension:

```{r}
distribution %<>% 
  mutate(Flanders = case_when(
    presence_fl == "X" & (is.na(presence_br) | presence_br == "?") & (is.na(presence_wa) | presence_wa == "?") ~ "S",
    presence_fl == "?" ~ "?",
    is.na(presence_fl) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Brussels = case_when(
    (is.na(presence_fl) | presence_fl == "?") & presence_br == "X" & (is.na(presence_wa) | presence_wa == "?") ~ "S",
    presence_br == "?" ~ "?",
    is.na(presence_br) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Wallonia = case_when(
    (is.na(presence_fl) | presence_fl == "?") & (is.na(presence_br) | presence_br == "?") & presence_wa == "X" ~ "S",
    presence_wa == "?" ~ "?",
    is.na(presence_wa) ~ "NA",
    TRUE ~ "M")) %>%
  mutate(Belgium = case_when(
    presence_fl == "X" | presence_br == "X" | presence_wa == "X" ~ "S", # One is "X"
    presence_fl == "?" | presence_br == "?" | presence_wa == "?" ~ "?" # One is "?"
  ))
```

Summary of the previous action:

```{r}
distribution %>% select(presence_fl, presence_br, presence_wa, Flanders, Wallonia, Brussels, Belgium) %>%
  group_by_all() %>%
  summarize(records = n()) %>%
  arrange(Flanders, Wallonia, Brussels)
```

One line should represent the presence information of a species in one region or Belgium. We need to transform `distribution` from a wide to a long table (i.e. create a `key` and `value` column):

```{r}
distribution <- 
  distribution %>% 
    gather(key, value, Flanders, Wallonia, Brussels, Belgium, convert = FALSE) %>%
    rename("location" = "key", "presence" = "value") %>% 
    filter(!presence == "NA") # Remove species for which we lack presence information (i.e. `presence` = `NA``)
```

### Mapping to Darwin Core

Define look-up table for pathways of introduction:

```{r}
lookup <- c(
    "agric." = "agriculture",
    "bird seed" = "seedContaminant",
    "birdseed" = "seedContaminant",
    "bulbs" = "",
    "coconut mats" = "seedContaminant",
    "fish" = "",
    "food refuse" = "liveFoodLiveBait",
    "grain" = "seedContaminant",
    "grain (rice)" = "seedContaminant",
    "grass seed" = "seedContaminant",
    "hay" = "",
    "hort" = "horticulture",
    "hort." = "horticulture",
    "hybridization" = "",
    "military troops" = "",
    "nurseries" = "contaminantNursery",
    "ore" = "transportationHabitatMaterial",
    "pines" = "contaminantOnPlants",
    "rice" = "",
    "salt" = "",
    "seeds" = "seedContaminant",
    "timber" = "timberTrade",
    "tourists" = "people",
    "traffic" = "",
    "unknown" = "unknown",
    "urban weed" = "stowaway",
    "waterfowl" = "ContaminantOnAnimals",
    "wool" = "ContaminantOnAnimals",
    "wool alien" = "ContaminantOnAnimals")
```


```{r}
distribution <- 
  distribution %>% 
    mutate(
      taxonID = taxon_id,
      locationID = case_when(
      location == "Belgium" ~ "ISO_3166-2:BE",
      location == "Flanders" ~ "ISO_3166-2:BE-VLG",
      location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
      location == "Brussels" ~ "ISO_3166-2:BE-BRU"),
    locality = case_when(
      location == "Belgium" ~ "Belgium",
      location == "Flanders" ~ "Flemish Region",
      location == "Wallonia" ~ "Walloon Region",
      location == "Brussels" ~ "Brussels-Capital Region"), 
    countryCode = "BE",
    occurrenceStatus = recode(presence,
     "S" = "present",
     "M" = "present",
      "?" = "presence uncertain",
     .default = ""), 
    establishmentMeans = "introduced",
    
  
    # Degree of establishment: step 1 - clean d_n
     d_n_clean = recode(d_n,
      "Cas." = "casual",
      "Cas.?" = "casual",
      "Inv." = "established",
      "Nat." = "established",
      "Nat.?" = "established",
      "Ext." = "extinct",
      "Ext.?" = "extinct",
      "Ext./Cas." = "casual",
      .missing = ""), 
  
    # Degree of establishment: step 2 - populate only when `presence`= `S`
    # We discard the terms `naturalized` and `invasive`. `naturalized` and `invasive` are replaced by `established`. For `extinct` and `extinct/casual` species, we map `extinct` and `casual` respectively)
    degreeOfEstablishment = case_when(
      presence == "S" ~ d_n_clean,
      TRUE ~ ""),
  
    # Pathway of introduction: step 1 - clean v_i
  
      pathway_clean = v_i %>% 
        str_replace_all("\\s+", " ") %>%  
        str_trim() %>%
        str_to_lower() %>%
        str_replace_all("(\\.\\.\\.|etc\\.)", "") %>% 
        str_split("\\s*,\\s*") %>% 
        map(str_trim) %>%
        map(~ str_remove(.x, "\\?+$")) %>%     # 6
        map(str_trim) %>%  
        map(~ .x[.x != "..."]) %>%
       map(~ recode(.x, !!!lookup, .default = .x)) %>%
       map(~ unique(.x)) %>%
       map_chr(~ paste(.x, collapse = " | ")),
  
      # Pathway of introduction: step 2 - populate only when `presence`= `S`
     pathway = case_when(
      presence == "S" ~ pathway_clean,
      TRUE ~ ""),
    
     eventDate = case_when(
      presence == "S" ~ date,  # Populate `eventDate` only when `presence` = `S`:
      TRUE ~ "")) %>%
    
    select(
      "taxonID", "locationID", "locality", "countryCode", "occurrenceStatus",
      "establishmentMeans", "degreeOfEstablishment", "pathway", "eventDate") %>%
    arrange(taxonID)
    
```

## Species profile extension

In this extension will express broad habitat characteristics (e.g. `isTerrestrial`) of the species.

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml):

```{r}
species_profile <- input_data %>% 
  mutate(
    habitat = str_to_lower(habitat),
    taxonID = taxon_id,
    isMarine = "FALSE",
    isFreshwater = case_when(
      habitat == "fresh water" | habitat == "terrestrial/fresh water" ~ "TRUE",
      TRUE ~"FALSE"),
    isTerrestrial = case_when(
      habitat == "terrestrial" | habitat == "terrestrial/fresh water" ~ "TRUE",
      TRUE ~"FALSE")) %>% 
  select(taxonID, isMarine, isFreshwater, isTerrestrial) %>% 
  arrange(taxonID)
    
```

## Description extension

Map the data to [Taxon Description](http://rs.gbif.org/extension/gbif/1.0/description.xml):

In the description extension we want to include the native range of the species. A single taxon can have multiple native ranges of the same type, expressed as multiple rows in the description extension. `origin` contains native range information (e.g. `E AS-Te NAM`). We'll separate, clean, map and combine these values.

```{r}
description <- input_data %>% 
  separate(origin,
           into = c("native_range_1", "native_range_2", "native_range_3", "native_range_4"),
           sep = " ",
           remove = TRUE, 
           convert = FALSE,
           extra = "merge",
           fill = "right") %>% 
  gather(key, value,
         native_range_1, native_range_2, native_range_3, native_range_4,
         na.rm = TRUE, # Also removes records for which there is no native_range_1
         convert = FALSE) %>% 
  mutate(value = str_replace_all(value, "\\?", ""), # Strip ?
         value = str_trim(value),
         description = recode(value,
                               "AF" = "Africa (WGSRPD:2)",
                               "AM" = "pan-American",
                               "AS" = "Asia",
                               "AS-Te" = "temperate Asia (WGSRPD:3)",
                               "AS-Tr" = "tropical Asia (WGSRPD:4)",
                               "AUS" = "Australasia (WGSRPD:5)",
                               "Cult." = "cultivated origin",
                               "E" = "Europe (WGSRPD:1)",
                               "Hybr." = "hybrid origin",
                               "NAM" = "Northern America (WGSRPD:7)",
                               "SAM" = "Southern America (WGSRPD:8)",
                               "Trop." = "Pantropical",
                               .default = "",
                               .missing = "" # As result of stripping, records with no native range already removed by gather()
                               )) %>% 
  filter(!is.na(description) & description != "") %>% 
  mutate(
    taxonID = taxon_id,
    language = "en",
    type = "native range") %>% 
  select(taxonID, description, type, language)
  
  
```






Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
write_csv(species_profile, here("data", "processed", "speciesprofile.csv"), na = "")
write_csv(description, here("data", "processed", "description.csv"), na = "")
```
